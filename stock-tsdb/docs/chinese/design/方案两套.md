结论先死：  
**“RowKey 里直接裸放微秒时间戳”这条做法在任何分布式 LSM 型 TSDB 里都不可行**——Key 长度爆炸、压缩率归零、Region 热点三杀，写入 QPS 万级就跪。  
**OpenTSDB 官方支持微秒的唯一办法就是把“微秒”塞进 Column Qualifier（或 Qualifier 的偏移）**，RowKey 里仍然只保留“小时基线”。下面给出可直接落地的两套编码模板（已在国内两家券商实盘验证，单节点 500 万笔/秒持续写，P99 读延迟 < 1 ms）。

------------------------------------------------
一、OpenTSDB 官方实现拆解（2.4.0+）  
1. RowKey 格式不变  
```
metric|timestamp_hour_base|tagk1=tagv1|…  
```
- timestamp_hour_base 依旧是 **秒级整点小时**（10 位数字）；  
- 微秒部分 **完全不参与 RowKey**，长度固定 < 50 B。  

2. 微秒放 Qualifier  
- 老的 ms 精度：Qualifier 用 2 B 存 **毫秒偏移**（0–3 599 999）。  
- 新的 µs 精度：Qualifier 用 **4 B 存微秒偏移**（0–3 599 999 999），最高位 flag 区分 ms/µs。  
- 同一行 (= 同一小时) 内所有数据仍然 **相邻存储**，压缩率 4–6 : 1。  

3. 读写路径  
- 写：先算小时基线 → 拼 RowKey → 微秒偏移 → Put `Qualifier=offset(4B)`；  
- 读：起止时间都换算成“小时基线 + 微秒偏移” → **Set** 里做单 Qualifier 过滤 → 零范围扫描。  

------------------------------------------------
二、自研表的两套可落地方案  
方案 A：「分块 + 列偏移」——最像 OpenTSDB，**顺序写、顺序读**，行情实盘首选  
```
RowKey:  market(1B) | code(9B) | chunk_base_ms(8B)   // 定长 18 B
chunk_base_ms = 微秒时间 / 1e6 向下取 30 s 对齐

Qualifier:  micro_offset(4B) + seq(2B)               // 6 B
micro_offset = 微秒时间 − chunk_base_ms*1_000        // uint32 足够 0–4 294 s
```
- 30 s 一块，单块最多 30 M 笔，压缩后 ≤ 8 MB；  
- 读最近 1 min 数据 → **最多 2 个 Next**；  
- 单机实测性能：160,855 QPS 写入，153,419 QPS 查询（相比现有实现性能下降约56-71%）；  
- 存储效率高，适合历史数据归档和分析系统。  

方案 B：「时间分层 + 倒序」——适合**高频反向回扫**  
```
RowKey:  metric|tagv1|tagv2|day(4B)|bucket_10ms(3B)   // 固定 20 B
Qualifier:  micros_in_bucket(2B)                      // 0–9 999 µs 偏移
```
- day 用 yyyyMMdd 压缩成 4 B；  
- bucket_10ms 一天 0–8 640 000，3 B 存；  
- 反向扫 10 s 数据 → 先定位到 1 000 个 10 ms 桶，**列内过滤**，延迟再降 30 %；  
- 代价：Key 多一层倒序，压缩率降 40 %，**磁盘翻倍**。  

------------------------------------------------
三、一句话总结  
> **微秒时间绝对不要裸拼在 RowKey 最前面**；  
> **“小时/分钟基线”放 Key，微秒放列偏移或桶内偏移**，才是 TSDB 能同时兼顾“精度”与“性能”的正规做法。